// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Array from "rescript/lib/es6/array.js";
import * as WebGL from "../Bindings/WebGL.mjs";
import * as Three from "three";
import * as Js_math from "rescript/lib/es6/js_math.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";

var t = Three;

var scene = [new (Three.Scene)()];

var pointTarget = [undefined];

var points = [[]];

var lines = [[]];

var vertexts = [[]];

var edges = [[]];

var force = [new (Three.Vector3)(0, 0, 0)];

function buildBackSpace(width, height) {
  var geometry = new (Three.PlaneBufferGeometry)(width * 2, height * 2);
  var params = JSON.parse("{\"color\": \"#469FA3\", \"transparent\": true}");
  var material = new (Three.MeshBasicMaterial)(params);
  var backSpace = new (Three.Mesh)(geometry, material);
  backSpace.position.x = 0;
  backSpace.position.y = 0;
  backSpace.position.z = -100;
  backSpace.receiveShadow = true;
  Caml_array.get(scene, 0).add(backSpace);
  
}

function createdPoint(id, x, y, z, r, pinned) {
  var p = new (Three.Vector3)(x, y, z);
  var o = new (Three.Vector3)(x, y, z);
  var pin = pinned || false;
  var networkPoint_pinned = pinned || false;
  var networkPoint = {
    id: id,
    position: p,
    oldPosition: o,
    radius: r,
    pinned: networkPoint_pinned
  };
  Caml_array.set(points, 0, $$Array.append(Caml_array.get(points, 0), [networkPoint]));
  var color = pin ? "#000000" : "#FFFFFF";
  var params = JSON.parse("{\"color\": \"" + ("" + color + "\"}"));
  var material = new (Three.MeshBasicMaterial)(params);
  var geometry = new (Three.SphereGeometry)(r, 30, 30);
  var mesh = new (Three.Mesh)(geometry, material);
  mesh.position.x = x;
  mesh.position.y = y;
  mesh.position.z = z;
  Caml_array.set(vertexts, 0, $$Array.append(Caml_array.get(vertexts, 0), [mesh]));
  Caml_array.get(scene, 0).add(mesh);
  
}

function makeEdge(v1, v2) {
  var p1 = Caml_array.get(Caml_array.get(points, 0), v1);
  var p2 = Caml_array.get(Caml_array.get(points, 0), v2);
  var d = p1.position.distanceTo(p2.position);
  var lineData = {
    p1: p1,
    p2: p2,
    dist: d
  };
  Caml_array.set(lines, 0, $$Array.append(Caml_array.get(lines, 0), [lineData]));
  var params = JSON.parse("{\"color\": \"#ffffff\"}");
  var material_line = new (Three.LineBasicMaterial)(params);
  var geometry_line = new (Three.Geometry)();
  geometry_line.vertices.push(p1.position, p2.position);
  var line = new (Three.Line)(geometry_line, material_line);
  Caml_array.set(edges, 0, $$Array.append(Caml_array.get(edges, 0), [line]));
  Caml_array.get(scene, 0).add(line);
  
}

function buildObject(width, height) {
  var radiusList = [
    22,
    30,
    37
  ];
  var colHeight = height / (7 - 3);
  var colWidth = width / (7 - 3);
  var xstart = width / 2 + colWidth;
  var ystart = height / 2 + colHeight;
  var id = [0];
  for(var row_index = 0; row_index <= 6; ++row_index){
    for(var column_index = 0; column_index <= 6; ++column_index){
      var radius = Caml_array.get(radiusList, Js_math.floor(Math.random() * radiusList.length));
      var x = -xstart + column_index * colWidth + (
        column_index % 6 !== 0 ? Math.random() * 300 : 0
      );
      var y = ystart - row_index * colHeight + (
        row_index !== 0 && row_index !== 7 - 1 ? Math.random() * 250 : 0
      );
      var pinned = column_index % 6 === 0 || row_index === 0 || row_index === 6;
      createdPoint(Caml_array.get(id, 0), x, y, 0, radius, pinned);
      Caml_array.set(id, 0, Caml_array.get(id, 0) + 1 | 0);
    }
  }
  for(var index = 1 ,index_finish = Caml_array.get(points, 0).length; index < index_finish; ++index){
    if (index % 7 !== 0) {
      makeEdge(index, index - 1 | 0);
    }
    if (index < ((Caml_array.get(points, 0).length - 7 | 0) + 1 | 0)) {
      makeEdge(index - 1 | 0, (index + 7 | 0) - 1 | 0);
    }
    
  }
  
}

function initScene(width, height) {
  Caml_array.set(scene, 0, new (Three.Scene)());
  Caml_array.set(pointTarget, 0, undefined);
  Caml_array.set(points, 0, []);
  Caml_array.set(lines, 0, []);
  Caml_array.set(vertexts, 0, []);
  Caml_array.set(edges, 0, []);
  Caml_array.set(force, 0, new (Three.Vector3)(0, 0, 0));
  buildBackSpace(width, height);
  return buildObject(width, height);
}

function onMouseOver($$event, width, height) {
  var clientX = WebGL.mouseX($$event);
  var clientY = WebGL.mouseY($$event);
  var mouse = new (Three.Vector2)(clientX - width / 2, -(clientY - height / 2));
  $$Array.mapi((function (index, vertext) {
          var p = vertext.position;
          var dx = mouse.x - p.x;
          var dy = mouse.y - p.y;
          var d = Math.sqrt(dx * dx + dy * dy);
          var point = Caml_array.get(Caml_array.get(points, 0), index);
          if (d <= point.radius && !point.pinned) {
            Caml_array.set(pointTarget, 0, point);
            Caml_array.get(force, 0).x = point.position.x;
            Caml_array.get(force, 0).y = point.position.y;
          }
          var target = Caml_array.get(pointTarget, 0);
          if (target === undefined) {
            return ;
          }
          var dx$1 = mouse.x - target.position.x;
          var dy$1 = mouse.y - target.position.y;
          if (Math.abs(dx$1) < width * 0.05) {
            Caml_array.get(force, 0).x = mouse.x;
          }
          if (Math.abs(dy$1) < height * 0.05) {
            Caml_array.get(force, 0).y = mouse.y;
            return ;
          }
          
        }), Caml_array.get(vertexts, 0));
  
}

function onMouseOut(param) {
  Caml_array.set(pointTarget, 0, undefined);
  return Caml_array.set(force, 0, new (Three.Vector3)(0, 0, Caml_array.get(force, 0).z));
}

function setEventsMouse(element, width, height) {
  element.onmousemove = (function (e) {
      return onMouseOver(e, width, height);
    });
  element.onmouseout = (function (_e) {
      return onMouseOut(undefined);
    });
  
}

function updateFource(param) {
  var target = Caml_array.get(pointTarget, 0);
  if (target !== undefined) {
    Caml_array.get(Caml_array.get(points, 0), target.id).position.x = Caml_array.get(force, 0).x;
    Caml_array.get(Caml_array.get(points, 0), target.id).position.y = Caml_array.get(force, 0).y;
    Caml_array.get(Caml_array.get(points, 0), target.id).position.z = target.position.z;
    return Caml_array.set(pointTarget, 0, {
                id: target.id,
                position: new (Three.Vector3)(Caml_array.get(force, 0).x, Caml_array.get(force, 0).y, target.position.z),
                oldPosition: target.oldPosition,
                radius: target.radius,
                pinned: target.pinned
              });
  }
  
}

function updatePoint(param) {
  return $$Array.mapi((function (index, networkPoint) {
                if (networkPoint.pinned) {
                  return ;
                }
                var positionX = networkPoint.position.x + (networkPoint.position.x - networkPoint.oldPosition.x * 1.0);
                var positionY = networkPoint.position.y + (networkPoint.position.y - networkPoint.oldPosition.y * 1.0);
                var positionZ = networkPoint.position.z + (networkPoint.position.z - networkPoint.oldPosition.z * 1.0);
                Caml_array.get(Caml_array.get(points, 0), index).oldPosition.x = networkPoint.position.x;
                Caml_array.get(Caml_array.get(points, 0), index).oldPosition.y = networkPoint.position.y;
                Caml_array.get(Caml_array.get(points, 0), index).oldPosition.z = networkPoint.position.z;
                Caml_array.get(Caml_array.get(points, 0), index).position.x = positionX;
                Caml_array.get(Caml_array.get(points, 0), index).position.y = positionY;
                Caml_array.get(Caml_array.get(points, 0), index).position.z = positionZ;
                
              }), Caml_array.get(points, 0));
}

function updateJoint(param) {
  $$Array.mapi((function (index, line) {
          var dx = line.p2.position.x - line.p1.position.x;
          var dy = line.p2.position.y - line.p1.position.y;
          var d = Math.sqrt(dx * dx + dy * dy);
          var difference = line.dist - d;
          var percen = difference / d * 0.5;
          var offsetX = dx * percen;
          var offsetY = dy * percen;
          if (!line.p1.pinned) {
            Caml_array.get(Caml_array.get(lines, 0), index).p1.position.x = Caml_array.get(Caml_array.get(lines, 0), index).p1.position.x - offsetX;
            Caml_array.get(Caml_array.get(lines, 0), index).p1.position.y = Caml_array.get(Caml_array.get(lines, 0), index).p1.position.y - offsetY;
          }
          if (!line.p2.pinned) {
            Caml_array.get(Caml_array.get(lines, 0), index).p2.position.x = Caml_array.get(Caml_array.get(lines, 0), index).p2.position.x + offsetX;
            Caml_array.get(Caml_array.get(lines, 0), index).p2.position.y = Caml_array.get(Caml_array.get(lines, 0), index).p2.position.y + offsetY;
            return ;
          }
          
        }), Caml_array.get(lines, 0));
  
}

function refreshMesh(param) {
  Caml_array.set(vertexts, 0, $$Array.mapi((function (index, networkPoint) {
              Caml_array.get(Caml_array.get(vertexts, 0), index).position.x = networkPoint.position.x;
              Caml_array.get(Caml_array.get(vertexts, 0), index).position.y = networkPoint.position.y;
              Caml_array.get(Caml_array.get(vertexts, 0), index).position.z = networkPoint.position.z;
              return Caml_array.get(Caml_array.get(vertexts, 0), index);
            }), Caml_array.get(points, 0)));
  return Caml_array.set(edges, 0, $$Array.mapi((function (index, edge) {
                    edge.geometry.verticesNeedUpdate = true;
                    edge.lineDistancesNeedUpdate = true;
                    return edge;
                  }), Caml_array.get(edges, 0)));
}

function animate(param) {
  updateFource(undefined);
  updatePoint(undefined);
  updateJoint(undefined);
  return refreshMesh(undefined);
}

var NetworkScene = {
  t: t,
  scene: scene,
  pointTarget: pointTarget,
  points: points,
  lines: lines,
  vertexts: vertexts,
  edges: edges,
  force: force,
  k: 0.05,
  resilient: 1.0,
  buildBackSpace: buildBackSpace,
  createdPoint: createdPoint,
  makeEdge: makeEdge,
  buildObject: buildObject,
  initScene: initScene,
  onMouseOver: onMouseOver,
  onMouseOut: onMouseOut,
  setEventsMouse: setEventsMouse,
  updateFource: updateFource,
  updatePoint: updatePoint,
  updateJoint: updateJoint,
  refreshMesh: refreshMesh,
  animate: animate
};

export {
  NetworkScene ,
  
}
/* t Not a pure module */
